////////////////////////////////////////////////////
//
//  build.gradle
//

apply plugin: 'eclipse'
apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'spring-boot'
apply plugin: 'application'
apply plugin: 'ftt-deploy'
apply plugin: 'org.hidetake.ssh'

apply from: 'project.gradle'

buildscript {
	repositories {
		mavenLocal()
		maven { url "http://maven-repo.four33.co.kr:18081/nexus/content/repositories/releases/" }
		//maven { url "http://maven-repo.four33.co.kr:18081/nexus/content/repositories/snapshots/" }
		mavenCentral()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.2.RELEASE")
		classpath('org.hidetake:gradle-ssh-plugin:1.1.4')
		classpath("ftt:ftt-deploy:1.0.+")
	}
}

repositories {
	mavenLocal()
	maven { url "http://maven-repo.four33.co.kr:18081/nexus/content/repositories/releases/" }
	//maven { url "http://maven-repo.four33.co.kr:18081/nexus/content/repositories/snapshots/" }
	mavenCentral()
}

dependencies {
	// ftt-common
	compile("ftt:ftt-common-lib:1.0.1")
	compile("ftt:ftt-common-default-web-api:1.0.0")

	// spring
	compile("org.springframework.boot:spring-boot-starter-web")
	compile("org.springframework:spring-context-support")
}

jar {
	manifest {
		attributes 'Implementation-Title': "${appName}", 'Implementation-Version': version
	}
}

// 파일 배포
task fttDeployFiles << {
	def port = Integer.parseInt("${wasPort}")
	assert port > 0
	
	ssh.run {
		session(remotes.role("${envType}-was")) {
			execute "mkdir -p /433/${appName}/${port}"
		}
	}

	for (def remote in remotes.role("${envType}-was")) {
		def cmd = "rsync -avrz --delete --exclude=.git --exclude=.gitmodules --exclude=.data ./build/ftt-deploy/ svcop@"+remote.host+":/433/${appName}/${wasPort}"
		println "[" + remote.host + "] " + cmd
		println cmd.execute().text
	}
}

// WAS 재시작
task fttRestartWas << {
	def port = Integer.parseInt("${wasPort}")
	assert port > 0
	
	ssh.run {
		session(remotes.role("${envType}-was")) {
			execute "nohup /433/${appName}/${port}/bin/${appName}.sh restart > /dev/null"
		}
	}

	print "restarted was port: ${port}"
}

// Nginx swap reload
task fttSwapReloadNginx << {
	def port = Integer.parseInt("${wasPort}")
	assert port > 0
	
	def nginxConfFileName = project.properties["${envType}.nginx.${wasPort}"]
	def nginxSymbolicLink = project.properties["${envType}.nginx.symlink"]
	if (nginxConfFileName == "" || nginxSymbolicLink == "") return
	
	ssh.run {
		session(remotes.role("${envType}-nginx")) {
			executeSudo "ln -sf ${nginxConfFileName} ${nginxSymbolicLink}", pty: true
			executeSudo "/usr/sbin/nginx -s reload", pty: true
		}
	}
}

// 서비스 포트 확인
task fttDeployTargetPort  << {
 	def port = fttGetWasPort()
	def newPort= fttGetNewWasPort(port)
	print "${newPort}"
}


// 현재 실행 중인 포트 확인
def fttGetWasPort() {
	if ("${envType}" == "localhost") {
		return Integer.parseInt(project.properties["${envType}.wasPort1"])
	}
	
	try {
		def svcChkPort = project.properties["${envType}.svcChkPort"]
		def wasPort = ssh.run {
			session(remotes.role("${envType}-check-port")) {
				// ssh로 접속 후 포트를 체크 하므로 localhost는 원격 호스트임
				// ftt-common/api/port를 통해 현재 서비스 중인 포트 확인 (ftt-common-default-web-api 에서 제공)
				execute("curl --connect-timeout 3 http://localhost:${svcChkPort}${appContextPath}/ftt-common/api/port 2> /dev/null", logging: "none");
			}
		}
		return Integer.parseInt(wasPort)
	} catch (Exception e) {
		return 0;
	}
}

// 현재 실행중이지 않은 배포되거나 WAS를 재시작해야하는 포트
def fttGetNewWasPort(port) {
	def fport = 0
	try {
		fport = Integer.parseInt("${forcePort}");
	} catch (Exception e) {
	}
	if (fport > 0) return fport;

	def wasPort1 = Integer.parseInt(project.properties["${envType}.wasPort1"])
	def wasPort2 = Integer.parseInt(project.properties["${envType}.wasPort2"])
	return port == wasPort1 ? wasPort2 : wasPort1
}